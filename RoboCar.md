# Разработка робототехнической платформы RoboCar

## Часть I техническая

**Элементная база:**

* Плата Arduino Uno R3 - 1 шт.
* Драйвер двигателей L293D - 1 шт.
* Сервомотор аналоговый SG90 - 1 шт.
* Мотор с редуктором TT прямой c двухсторонним валом и колесо - 2 шт.
* Ультразвуковой датчик расстояния HC-SR04 - 1 шт.
* Датчик скорости щелевой, LM393  - 2 шт.
* Модуль Bluetooth HC-05 - 1 шт.
* Резисторы 1k и 2k - 1 шт.
* Аккумулятор 5-12 В  - 1 шт.
* Батарея типа крона 9V - 1 шт.
* Батарейный отсек крона BS-IS (или клемма на крону) - 1 шт.
* Макетная плата 400 точек - 1шт.
* Пластиковое шасси - 1 шт.
* Кодовый диск для инкрементального энкодера - 2 шт.
* Винты М3x8 и гайки - 8 шт.
* Винты M3x30 и гайки - 4 шт.
* Винты М2x8 и гайки - 2 шт.
* Стойка для печатных плат латунная или силиконовая 10 мм - 4 шт.
* Колесо поворотное 25мм - 1 шт.
* Провода dupont.

### Сборка
1. Припаяйте провода dupont к контактам мотора с редуктором 

   <img   src="https://github.com/Markell/USonicRoboCar/blob/main/img/a1.jpg" alt="a1" style="zoom: 15%;border-radius: 60px;" />

2. Закрепите диски энкодера на валах моторов

   <img src="https://github.com/Markell/USonicRoboCar/blob/main/img/a2.jpg" alt="a2" style="zoom: 15%;border-radius: 60px;" />

3. Зафиксируйте моторы на шасси с помощью длинных винтов

   <img src="img\a3.jpg" alt="a3" style="zoom: 15%;border-radius: 60px;" />

4. Прикрепите поворотное колесо при помощи коротких винтов и стоек как показано на фото ниже и установите колеса на валах моторов

   <img src="img\a5-2.jpg" alt="a5" style="zoom: 15%;border-radius: 60px;" />

5. Установите датчики скорости зафиксировав их с помощью винтов M2

   <img src="https://github.com/Markell/USonicRoboCar/blob/main/img/a5.jpg" alt="a5" style="zoom: 15%;border-radius: 60px;" />

6. Приклейте плату Arduino и драйвер двигателей на поверхности шасси при помощи клеевого пистолета так, чтобы концы проводов от моторов доставали до клем (зеленые на фото ниже) драйвера двигателей.

   <img src="https://github.com/Markell/USonicRoboCar/blob/main/img/a7.jpg" alt="a7" style="zoom: 15%;border-radius: 60px;" />

7. При помощи клеевого пистолета зафиксируйте блок питания на поверхности шасси

   <img src="https://github.com/Markell/USonicRoboCar/blob/main/img/a8.jpg" alt="a8" style="zoom: 15%;border-radius: 60px;" />

8. Зафиксируйте ультразвуковой датчик на выступе сервомотора при помощи клеевого пистолета, как показано на фото ниже

   <img src="https://github.com/Markell/USonicRoboCar/blob/main/img/a9.jpg" alt="a9" style="zoom: 15%;border-radius: 60px;" />

9. При помощи клеевого пистолета зафиксируйте рупор сервомотора на переднем крае шасси и установите на него сервомотор с  ультразвуковым датчиком.

   <img src="https://github.com/Markell/USonicRoboCar/blob/main/img/a10.jpg" alt="a10" style="zoom: 15%;border-radius: 60px;" />

10. В соответствии с приведенной схемой подключите моторы к драйверу двигателей, а также датчики, модуль Bluetooth и сревомор к плате Arduino, в конце подключите блок питания и батарею типа крона.

    <img src="https://github.com/Markell/USonicRoboCar/blob/main/img/a11.jpg" alt="a10" style="zoom: 15%;border-radius: 60px;" />

### Электрическая схема проекта

<img src="https://github.com/Markell/USonicRoboCar/blob/main/img/RoboCar.png" alt="a10" style="zoom: 120%;" />

### Описание работы элементов робототехнической платформы

#### Управление мотором постоянного тока

Чтобы иметь полный контроль над мотором постоянного тока (DC мотор) , мы должны контролировать его скорость и направление вращения. Это может быть достигнуто путем объединения двух методов:

*  ШИМ (PWM)  - для управления скоростью
* H-мост (H-Bridge) - для управления направлением вращения

##### **ШИМ (PWM)**

Скоростью мотора постоянного тока можно управлять, изменяя его входное напряжение. Распространенным методом для этого является использование ШИМ (широтно-импульсной модуляции).

ШИМ — это метод, при котором среднее значение входного напряжения регулируется путем отправки серии импульсов ВКЛ-ВЫКЛ. Среднее напряжение пропорционально ширине импульсов, известной как рабочий цикл. Чем длиннее рабочий цикл, тем выше среднее напряжение, подаваемое на мотор постоянного тока (что приводит к более высокой скорости), и чем короче рабочий цикл, тем ниже среднее напряжение, подаваемое на мотор (что приводит к более низкой скорости).

На изображении ниже показан метод ШИМ с различными рабочими циклами и средним напряжением.

<img src="https://github.com/Markell/USonicRoboCar/blob/main/img/e1.png" alt="e1" style="zoom:110%;" />

##### **H-мост (H-Bridge) **

Направление вращения мотора постоянного тока можно контролировать, изменяя полярность его входного напряжения. Распространенным методом для этого является использование H-моста.

Схема Н-моста состоит из четырех переключателей с мотором в центре, образующих Н-подобную схему. Замыкание двух определенных переключателей одновременно меняет полярность напряжения, подаваемого на мотор. Это приводит к изменению направления вращения мотора.

Следующая анимация показывает принцип работы схемы Н-моста.

<img src="https://github.com/Markell/USonicRoboCar/blob/main/img/e1.gif" alt="e1" />

##### **Распиновка драйвера двигателей L293D**

Драйвер двигателей L293D — это двухканальный H-мост, способный управлять парой двигателей постоянного тока или одним шаговым двигателем. Это означает, что он может управлять двумя двигателями по отдельности, что делает его идеальным решением для создания данного проекта.

![e3](https://github.com/Markell/USonicRoboCar/blob/main/img/e3.png)

В данном проекте мы используем готовый модуль на базе чипа L293D он подходит для управления 1 шаговыми, 2 серво или 2 обычными двигателями постоянного тока. Драйвер способен работать с электромоторами постоянного тока с напряжением до +25 В и максимальным током до 1.2 А на канал. 

<img src="https://github.com/Markell/USonicRoboCar/blob/main/img/e3.jpg" alt="e3" style="zoom:80%;" />

Давайте познакомимся со всеми пинами по очереди.

**Контакты питания**

![e3](https://github.com/Markell/USonicRoboCar/blob/main/img/e4.png)

L293D имеет два вывода питания — VS и VSS.

**VS (Vcc2)** - контакт подает питание на H-мост микросхемы для управления двигателями.

**VSS (Vcc1)** - вывод используется для управления внутренней логической схемой, на него должно подаваться напряжение 5 В.

**GND** - выводы являются общими контактами заземления. Все 4 контакта GND внутри соединены и используются для отвода тепла, выделяемого в условиях высокой нагрузки.

**Выходные контакты**

![e5](https://github.com/Markell/USonicRoboCar/blob/main/img/e5.png)

Выходные каналы драйвера двигателя L293D для двигателей A и B выведены на контакты **OUT1 (A+)**, **OUT2 (A-)** и **OUT3 (B+)**, **OUT4 (B-)** соответственно. К этим контактам можно подключить два двигателя c допустимым напряжением 5–36В.

Каждый канал микросхемы может подавать до 600 мА на двигатель. Однако количество тока, подаваемого на двигатель, зависит от источника питания системы.

**Контакты управления направлением**

Используя контакты управления направлением, вы можете задавать направление двигателей, вперед или назад. Эти контакты фактически управляют переключателями схемы H-моста внутри микросхемы.

![e5](https://github.com/Markell/USonicRoboCar/blob/main/img/e6.png)

Микросхема имеет два контакта управления направлением для каждого канала. Контакты **IN1** и **IN2** управляют направлением вращения двигателя **А**; В то время как **IN3** и **IN4** управляют направлением вращения двигателя **B**.

Направление вращения двигателя можно контролировать, подавая на эти входы логический + (HIGH) (+5 В) или логический - (LOW) (земля). В приведенной ниже таблице показано, как это реализовано на примере IN1 и IN2.

|   IN1   |   IN2   | Направление вращения |
| :-----: | :-----: | :------------------: |
| LOW(0)  | LOW(0)  |  Двигатель выключен  |
| HIGH(1) | LOW(0)  |        Вперед        |
| LOW(0)  | HIGH(1) |        Назад         |
| HIGH(1) | HIGH(1) |  Двигатель выключен  |

**Контакты управления скоростью**

![e5](https://github.com/Markell/USonicRoboCar/blob/main/img/e7.png)

Выводы управления скоростью **ENA (EN1)** и **ENB (EN2)** используются для включения/выключения двигателей и управления их скоростью.

При подаче HIGH моторы будут вращаться, а если подать LOW они остановятся. Но с широтно-импульсной модуляцией (ШИМ) вы можете контролировать скорость вращения двигателей.

#### Измерение скорости мотора

##### **Распиновка ИК-модуля LM393**

![](https://github.com/Markell/USonicRoboCar/blob/main/img/e8.jpg)

Модуль имеет две вертикальные стойки с ИК-светодиодом на одной и фототранзистором на другой. Всякий раз, когда пространство между ИК-светодиодом и фототранзистором перекрывается, на вывод D0 генерируется сигнал высокого (HIGH) уровня.

По факту LM393 является микросхемой компаратора, а не датчиком как таковым. Схема нашего ИК-модуля выглядит следующим образом:

![e9](https://github.com/Markell/USonicRoboCar/blob/main/img/e9.jpg)

Здесь мы видим, насколько проста схема модуля. При отсутствии препятствия между ИК-светодиодом (IR LED) и фототранзистором (Photo Transistor) напряжение между положительным и отрицательным выводами компаратора одинаково. Когда фототранзистор заблокирован, он потребляет более высокое напряжение, делая  напряжение на положительном входе  более высоким  чем на отрицательном входе. Таким образом, на выводе D0 будет генерироваться сигнал высокого (HIGH) уровня, равный напряжению подаваемому на  Vcc.

##### **Кодовый диск для энкодера**

Теперь разберёмся как диск энкодера который мы установили на вал нашего метра поможет нам определить его скорость.

<img src="https://github.com/Markell/USonicRoboCar/blob/main/img/a2.jpg" alt="a2" style="zoom: 15%;border-radius: 60px;" />

При правильном размещении слоты на диске энкодера будут блокировать или пропускать свет ИК-светодиода. Это  создаст последовательность импульсов, частота которых пропорциональна скорости нашего мотора.

![e10](https://github.com/Markell/USonicRoboCar/blob/main/img/e10.jpg)

Изображенный выше диск энкодера имеет 20 слотов (прорезей). Следовательно, при подсчете 20 импульсов будет означать, что колесо совершило один полный оборот. Зная количество импульсов которое мы получаем в секунду, мы можем определить фактическую скорость колеса.

> ⚠**Примечание**. Обратите внимание что речь идет о «скорость колеса», а не «скорость мотора», так как они разные, поскольку наш мотор оснащен редуктором, который замедляет его вращение.

##### **Расчет скорости колеса**

В качестве примера, если мы будем измерять ровно 20 импульсов в секунду, то наше колесо будет вращаться со скоростью один оборот в секунду. Умножив это значение на 60, мы получим скорость в оборотах в минуту, которая в данном примере составит 60 об/мин.

Определив скорость вращения колеса, мы можем использовать математику для расчета нескольких других полезных параметров:

- Мы можем получить фактическую скорость (в километрах или милях в час) нашего робота.
- Мы можем определить, какое расстояние прошел наш робот.
- Мы можем узнать, что колесо действительно вращается, а не застряло и не движется.

Чтобы получить два первых параметра, нам нужно знать еще одну вещь, а именно длину окружности самого колеса. Есть два способа получить это значение:

- Измерить. Используйте гибкую измерительную ленту или кусок веревки, обернутой вокруг колеса, замерить его длину.
- Рассчитать. Умножить диаметр колеса на число пи (3,14), чтобы получить длину его окружности.

Вы, наверное, понимаете, почему это значение так важно -  окружность колеса равна расстоянию, которое колесо проходит за один оборот (при условии, что у нас идеальное сцепление с поверхностью, по которой едет робот).

Например, измерив одно из колес которые мы использовали при сборке, мы получим диаметр 66,1 мм. Далее, используя формулу, мы приходим к следующему:
$$
66.1 * \pi = 207.6
$$
Итак, наше колесо имеет окружность 207,6 мм. Рулетка, обернутая вокруг колеса, подтверждает, истинность этого значения.

##### **Прерывания**

Если вы обратите внимание на электрическую схему нашего проекта, то заметите что выходные пины ик-датчика скорости подключены к цифровым пинам Arduino Uno  2 и 3, это так называемые пины прерывания.

Прерывания — очень важная концепция при написании кода для любого компьютера, будь то крошечный Arduino или полноценный настольный компьютер под управлением Windows, Linux или MacOs. Хорошим примером использования прерываний является получение данных с клавиатуры. Один из способов получить данные клавиатуры — написать программу, которая постоянно проверяет клавиатуру, чтобы узнать, была ли нажата клавиша. Такая программа будет работать но некоторыми недостатками:

- Это затратно. Вы тратите много времени на запросы к клавиатуре только для того, чтобы узнать, что новых данных нет.
- Можно пропустить данные. Если клавиша нажата в то время как ваша программа выполняет другую функцию, она может пропустить нажатие клавиши.

Прерывания позволяют сделать это гораздо лучше. Вместо того, чтобы постоянно опрашивать клавиатуру, программа по большей части игнорирует клавиатуру. Но когда на клавиатуре нажимается клавиша, генерируется «аппаратное прерывание» - цифровой сигнал, который говорит компьютеру: «Прекрати все, что ты делаешь, и переключись на это». Затем компьютер запускает некоторый код, называемый «обработчик прерываний», который в случае с клавиатурой определяет, какая клавиша была нажата. Затем он предпринимает любые действия, необходимые для обработки этого нажатия клавиши, после чего возвращается к тому что выполнял ранее.

Это намного эффективнее, потому что компьютер не тратит время на проверку клавиатуры, пока не получит уведомление о том, что клавиша действительно была нажата.

> ⚠**Примечание**. Обратите внимание что при вызове функции прерывания, программа выполняемая до этого будет прервана, и возобновит свою работу только после окончания функции прерывания.

##### **Типы прерываний**

Вы могли заметить, что в предыдущем примере мы использовали термин «аппаратное прерывание», однако существую и другие типы прерываний.

Во-первых стоит упомянуть, что существуют как аппаратные, так и программные прерывания. 8-битные процессоры AVR, на которых работают платы Arduino, не поддерживают программные прерывания (в отличие от процессора настольного компютера), поэтому мы ограничим наше обсуждение аппаратными прерываниями.

Аппаратные прерывания можно разделить на две категории — внутренние и внешние.

Внутренние аппаратные прерывания генерируются внутренними таймерами в процессорах AVR,  их используют функции синхронизации, такие как `delay()`, `millis()` и `micros()`. Функция `tone()` также использует внутренние прерывания, как и библиотека Servo к которой мы еще вернемся.

Внешние аппаратные прерывания, как следует из их названия, генерируются от внешнего аппаратного устройства. В Arduino эти прерывания могут генерироваться двумя способами:

- Изменение сигнала на контакте. В таком случае Arduino вызовет обработчик прерываний, когда на пине прерывания (в нашем случае это 2 и 3 пины) происходит изменение сигнала.
- Cпециальный режим «pin-change». Этот режим работает по изменению входа для всех пинов. Отличие от предыдущего типа заключается в том, что прерывания могут генерироваться на любом из восьми контактов. Обработка в таком случае будет сложнее и дольше, так как придется отслеживать последнее состояние на каждом из контактов.

Внутри процессоров AVR, на которых основаны Arduino, используется иная система нумерации (INT), отличная от той которая использует номера пинов (D0, D1 и т.д.). Ниже приведена таблица, которая поясняет, как номера контактов связаны с некоторыми моделями Arduino:

| Модель Arduino                                               | **INT 0** | **INT 1** | **INT 2** | **INT 3** | **INT 4** | **INT 5** |
| ------------------------------------------------------------ | --------- | :-------: | :-------: | :-------: | :-------: | :-------: |
| Arduino на базе микроконтроллера ATmega 328/168 (Nano, UNO, Mini) | D2        |    D3     |     -     |     -     |     -     |     -     |
| Arduino на базе микроконтроллера ATmega 32U4       (Leonardo, Micro) | D3        |    D2     |    D0     |    D1     |    D7     |     -     |
| Arduino на базе микроконтроллера ATmega 2560       (Mega)    | D2        |    D3     |    D21    |    D20    |    D19    |    D18    |

В шашнем примере мы используем Arduino Uno следовательно, пины  2 и 3  будут обрабатывать прерывания. 

##### Прерывания в языке Arduino

Ключевой концепцией программирования прерываний заключается в  том, что для каждого прерывания требуется «процедура обслуживания прерывания» (“Interrupt Service Routine”) или «ISR», специальная функция, которая запускается при обнаружении прерывания. Они программируются как обычные функции в Arduino но со следующими оговорками:

- Подпрограмма обслуживания прерываний (ISR) должна выполняться быстро, поэтому она должна иметь минимальный объем кода.
- Существуют определенные функции и команды, которые не работают с ISR, особенно функции, использующие внутренние таймеры Arduino. К таким функциям можно отнести `delay()`, `tone()` , функции библиотеки Servo и другие описанные ранее в тексте. По этой же причине нельзя использовать протоколы связи, основанные на прерываниях (например, i2c).
- Иногда переменные, используемые с ISR, рассматриваются компилятором Arduino IDE как неиспользуемые. Если это произойдет, код программы не будет выполнятся, а решение состоит в том, чтобы объявить такие переменные как «volatile» («изменчивыми»). volatile — ключевое слово или спецификатор переменной, которое информирует компилятор о том, что значение переменной может меняться из вне и что компилятор не будет оптимизировать эту переменную.
- Не рекомендуется использовать большое количество прерываний (старайтесь не использовать более 6-8). Большое количество разнообразных событий требует серьезного усложнения кода, а, значит,  ведет к ошибкам. К тому же надо понимать, что ни о какой временной точности исполнения в системах с большим количеством прерываний речи быть не может – вы никогда точно не поймете, каков промежуток между вызовами важных для вас команд.

Чтобы функция ISR запускалась при обнаружении прерывания, ее необходимо привязать к конкретному аппаратному прерыванию, которое она будет  обслуживать. Делается это с помощью функции `attachInterrupt()`. Эта функция имеет следующий формат:
```c++
attachInterrupt(interrupt, function, mode)
```

Аргументы функции:

- `interrupt` – номер вызываемого прерывания (`0` – для 2-го пина,  `1` – для 3-го пина (обратитесь к таблице выше)).
- `function` – название вызываемой функции при прерывании (важно – функция не должна ни принимать, ни возвращать какие-либо значения).

- `mode` – условие срабатывания прерывания. Возможна установка следующих вариантов условий:
  - `LOW` – выполняется по низкому уровню сигнала, когда на контакте нулевое значение. Прерывание может циклично повторяться – например, при нажатой кнопке.
  - `CHANGE` – прерывание происходит при изменении сигнала с высокого на низкий или наоборот. Выполняется один раз при любой смене сигнала.
  - `RISING` – выполнение прерывания один раз при изменении сигнала от LOW к HIGH.
  - `FALLING` – выполнение прерывания один раз при изменении сигнала от HIGH к LOW.

Таким образом, следующий оператор вызовет функцию с именем «My_ISR», когда прерывание под номером 0 переходит от низкого уровня (LOW) сигнала к высокому (HIGH):

```c++
attachInterrupt(0, MY_ISR, RISING);
```

##### Улучшенный код прерывания

Предыдущий пример вполне корректен, но он требует, чтобы мы знали, к какому номеру прерывания привязан наш пин прерывания. Поскольку это зависит от того, какую модель Arduino мы используем, программа не будет работать на всех моделях Arduino. 

Более удобным  было бы использование функции `digitalPinToInterrupt()`. Эта функция принимает номер пина и возвращает номер прерывания в зависимости от вашей модели Arduino. 

Используя ее, наш предыдущий оператор будет выглядеть следующим образом, беря во внимание что мы используем Arduino Uno:
```c++
attachInterrupt(digitalPinToInterrupt(2), MY_ISR, RISING);
```

 Функция digitalPinToInterrupt вернет `0`, поскольку Arduino Uno имеет номер прерывания `0`, привязанный к пину 2.

#### Управление сервомотором

Сервомоторы или сервоприводы — это моторы, которые позволяют вам точно контролировать физическое движение, поскольку как правило они перемещаются в определенное положение, а не непрерывно вращаются. Они просты в подключении и управлении, потому что драйвер двигателя встроен прямо в них.

Сервоприводы содержат небольшой мотор постоянного тока, соединенный с выходным валом через шестерни. Выходной вал приводит в движение рупор сервопривода, а также связан с потенциометром.

<img src="https://github.com/Markell/USonicRoboCar/blob/main/img/e11.png" alt="e11" />

Потенциометр предаёт позиционную обратную связь на усилитель ошибки в блоке управления, который сравнивает текущее положение двигателя с заданным положением. В ответ на ошибку блок управления корректирует текущее положение двигателя, чтобы оно соответствовало желаемому положению. В теории автоматического управления этот механизм известен как сервомеханизм или сервопривод для краткости. Это замкнутая система управления которая использует отрицательную обратную связь для регулировки скорости и направления двигателя для достижения желаемого результата.

<img src="https://github.com/Markell/USonicRoboCar/blob/main/img/e12.png" alt="e12" style="zoom:130%;" />

Вы можете управлять серводвигателем, посылая на него серию импульсов. Обычный серводвигатель ожидает импульс каждые 20 миллисекунд (т. е. сигнал должен быть с частой 50 Гц). Длина импульса определяет положение сервомотора.

<img src="https://github.com/Markell/USonicRoboCar/blob/main/img/e13.png" alt="e13" />

1. Короткий импульс длительностью 1 мс или меньше повернет сервопривод на 0 градусов.
2. Импульс длительностью 1,5 мс повернет сервопривод на 90 градусов.
3. Импульс длительностью 2 мс или около того повернет сервопривод на 180 градусов.

Импульсы в диапазоне от 1 мс до 2 мс будут поворачивать сервопривод в положение, пропорциональное ширине импульса.

<img src="https://github.com/Markell/USonicRoboCar/blob/main/img/e14.gif" alt="e14" />

> ⚠**Примечание**. Обратите внимание что не существует стандарта для точного соотношения между импульсами и положением, поэтому вам может потребоваться подредактировать свой код, чтобы отрегулировать диапазон вашего сервопривода.
>
> Кроме того, длительность импульса может варьироваться в зависимости от марки сервопривода; например, это может быть 2,5 мс для 180 градусов и 0,5 мс для 0 градусов.

##### Распиновка сервомотора

Сервомоторы обычно имеют три соединения, как показано ниже.

<img src="https://github.com/Markell/USonicRoboCar/blob/main/img/e15.png" alt="e15" />

**GND** - общая земля для логики и для мотора

**5V** -  питания сервопривода

**Control** - сигнал управления (PWM)

> ⚠**Примечание**. Обратите внимание что цвет проводов зависит от серводвигателя, но красный провод всегда 5 В, а GND либо черный, либо коричневый. Провод управления обычно оранжевый или желтый.

В нашем проекте мы используем сервомотор SG90. Он работает от 4,8-6 В постоянного тока (обычно 5 В) и может поворачиваться на 180 градусов (90 градусов в каждом направлении). Он потребляет около 10 мА в режиме ожидания и от 100 мА до 250 мА во время движения, поэтому мы можем питать его от 5-вольтового пина Arduino. Для управления сервомоторам используется ШИМ (PWM) пин Arduino (подробнее в разделе [ШИМ](#ШИМ-(PWM)))

#### Измерение расстояния до препятствия 

Работа модуля  HC-SR04 основана на принципе эхолокации. Модуль посылает ультразвуковой сигнал и принимает его отражение от объекта. Измерив время между отправкой и получением импульса, не сложно вычислить расстояние до препятствия.

##### Распиновка ультразвукового датчика HC-SR04

<img src="https://github.com/Markell/USonicRoboCar/blob/main/img/e19.png" alt="e19" />

**VCC** подает питание на ультразвуковой датчик

**Trig (Trigger)** используется для отправки ультразвуковых импульсов.

**Echo** используется для получения ультразвуковых импульсов. Подаваемый на Arduino сигнал  становится высоким (HIGH) при передаче ультразвукового импульса и остается высоким до тех пор, пока датчик не получит эхо-сигнал, после чего он становится низким (LOW).

**GND** пин заземления.



##### Что такое ультразвук

Ультразвук представляет собой звуковую волну высокой частоты, частота которой превышает слышимый диапазон человеческого слуха.

<img src="https://github.com/Markell/USonicRoboCar/blob/main/img/e16.png" alt="e16" />

Люди могут слышать звуковые волны, частота колебаний которых составляет от 20 раз в секунду (глубокий рокот) до 20 000 раз в секунду (высокий свист). Однако ультразвук имеет частоту более 20 000 Гц и поэтому не слышен человеку.

##### Как работает ультразвуковой датчик расстояния HC-SR04

Все начинается с того, что на пин trigger подается сигнал высокого (HIGH) уровня на 10µs (микросекунд). В ответ датчик передает ультразвуковой пакет из восьми импульсов частотой 40 кГц. В ответ модуль генерирует пучок из восьми импульсов частотой 40 кГц. Эта 8-импульсная последовательность специально сделана для того, чтобы приемник мог отличать передаваемые импульсы от окружающего ультразвукового шума.

Эти восемь ультразвуковых импульсов распространяются по воздуху от передатчика. Тем временем на пине Echo устанавливается высокий (HIGH) уровень, чтобы инициировать сигнал обратного эха. 

Если эти импульсы не отражаются обратно, время ожидания эхо-сигнала истекает, и через 38 мс (миллисекунд) он становится низким. Таким образом, импульс длительностью 38 мс указывает на отсутствие препятствий в зоне действия датчика.

<img src="https://github.com/Markell/USonicRoboCar/blob/main/img/e17.gif" alt="e17" />

Если эти импульсы отражаются обратно, вывод Echo станет низким (LOW), как только сигнал будет получен. Это генерирует электрический импульс на выводе Echo, ширина которого варьируется от 150 µs до 25 мс в зависимости от времени, необходимого для приема сигнала.

<img src="https://github.com/Markell/USonicRoboCar/blob/main/img/e18.gif" alt="e18" />

##### Вычисление расстояния

Ширина полученного импульса используется для расчета расстояния до отраженного объекта. Это можно сделать, используя простое уравнение расстояние-скорость-время, знакомое нам еще со школы. Простой способ запомнить это уравнение — сложить буквы треугольником.

<img src="https://github.com/Markell/USonicRoboCar/blob/main/img/e17.png" alt="e17" />

Приведем пример, чтобы было нагляднее. Предположим, у нас есть объект перед датчиком на неизвестном расстоянии, и мы получаем импульс с пина Echo шириной 500µs. Теперь давайте посчитаем, на каком расстоянии объект находится от датчика. Для этого мы будем использовать приведенное ниже уравнение. 
$$
Расстояние = Скорость*Время
$$
Получив значение времени, т.е. 500 µs, и зная скорость распространения звука в воздухе - 340 м/с. мы можем рассчитать расстояние, для этого нам нужно преобразовать скорость звука в см/µs, что составит 0,034 см/µs. В результате у нас получится следующая формула:
$$
Расстояние = 0.034см/µs*500µs
$$
Как мы помним: эхо-импульс указывает на время время, необходимое для отправки сигнала и отражения обратно. Таким образом, чтобы получить расстояние, вы должны разделить полученный результат на два.
$$
Расстояние = {0.034см/µs*500µs\over 2}
=> Расстояние = 8,5 см
$$


#### Беспроводная передача данных

Для придачи данных на компьютер мы будем использовать Bluetooth-модуль HC-05. Устройство построено на базе чипа CSR BC417, который поддерживает радиосигнал по протоколу Bluetooth 2.0 + EDR (Enhanced Data Rate — дословно «усовершенствованная передача данных») со скоростью до 3 Мбит/сек. На самой плате находится антенна из дорожки в виде змейки, обеспечивающая дальность связи до 10 метров. Чип поддерживает AT-команды, может работать в режиме Master или Slave, поддерживает скорость обмена от 2400 до 1 382 400.

> ⚠**Примечание**. Обратите внимание что cкорость 9600 является скоростью обмена по умолчанию для модуля Bluetooth HC-05.

##### Master (ведущий)/Slave (ведомый)

Ведущий / ведомый - это модель связи для аппаратных устройств, где одно устройство имеет однонаправленный контроль над одним или несколькими устройствами. Это часто используется в электронном аппаратном пространстве, где одно устройство действует как контроллер, тогда как другие устройства являются теми, которыми управляют. Короче говоря, один - хозяин, а другие - рабы, которыми управляет мастер.

<img src="https://github.com/Markell/USonicRoboCar/blob/main/img/e21.jpg" alt="e1" />

##### Распиновка Bluetooth-модуля HC-05

![e20](https://github.com/Markell/USonicRoboCar/blob/main/img/e20.png)

1. **Enable / Key** этот контакт используется для переключения между режимом данных (Data Mode) (LOW уровень сигнала) и режимом AT-команд (HIGH уровень). По умолчанию он находится в режиме данных

2. **VCC** контакт питания 3,6 – 6 В

3. **Ground** контакт заземления

4. **Tx** (Transmitter)  передает последовательные данные. Все, что принимается через Bluetooth, будет выдаваться этим пином как последовательные данные..

5. **Rx** (Receiver)  получает последовательные данные. Все последовательные данные, передаваемые на этот рин, будут транслироваться через Bluetooth.

6. **State** контакт состояния подключен к встроенному светодиоду, его можно использовать в качестве обратной связи для проверки корректности работы Bluetooth.

7. **LED** отображает состояние модуля

   * Мигает один раз в 2 секунды: модуль перешел в командный режим.

   * Повторяющееся мигание: ожидание соединения в режиме передачи данных

   * Мигает дважды в 1 секунду: успешное соединение в режиме передачи данных

8. **Button** (кнопка) используется для управления выводом Key/Enable для переключения между режимами данных и AT-команд.

##### Режимы работы

HC-05 имеет два режима работы: 

- Командный режим. В командном режиме мы можем связываться с модулем Bluetooth с помощью AT-команд для настройки различных параметров и настроек модуля, таких как получение информации о прошивке, изменение скорости передачи данных, изменение имени модуля, это можно использовать для установки его в качестве master или slave. Особенность модуля HC-05 заключается в том, что его можно настроить как ведущий или ведомый в коммуникационной паре. Чтобы выбрать любой из режимов, нам необходимо активировать командный режим и отправить соответствующие AT-команды.
- Режим данных. В этом режиме модуль используется для связи с другим устройством Bluetooth, т.е. передача данных происходит именно в этом режиме.



## Часть II Программная

### Скетч для Arduino

#### Программа управления мотором постоянного тока

Следующий скетч даст нам полное понимание того, как контролировать скорость и направление вращения двигателей постоянного тока с помощью драйвера двигателей L293D.

```C++
// Подключение мотора A
int enA = 9;
int in1 = 8;
int in2 = 7;
// Подключение мотора B
int enB = 3;
int in3 = 5;
int in4 = 4;

void moveForward(int speed) {
    // Установить параметр скорости для моторов
	analogWrite(enA, speed);
	analogWrite(enB, speed);
    
	// Вращать левый мотор вперед
	digitalWrite(in1, LOW);
	digitalWrite(in2, HIGH);

	// Вращать правый мотор вперед
	digitalWrite(in3, HIGH);
	digitalWrite(in4, LOW);
}

void moveReverse(int speed) {
    // Установить параметр скорости для моторов
	analogWrite(enA, speed);
	analogWrite(enB, speed);
    
	// Вращать левый мотор назад
	digitalWrite(in1, HIGH);
	digitalWrite(in2n, LOW);

	// Вращать правый мотор назад
	digitalWrite(in3, LOW);
	digitalWrite(in4, HIGH);
}

void moveRight(int speed) {
    // Установить параметр скорости для моторов
	analogWrite(enA, speed);
	analogWrite(enB, speed);
    
	// Вращать левый мотор назад
	digitalWrite(in1, HIGH);
	digitalWrite(in2, LOW);

	// Вращать правый мотор вперед
	digitalWrite(in3, HIGH);
	digitalWrite(in4, LOW);
}

void moveLeft(int speed) {
    // Установить параметр скорости для моторов
	analogWrite(enA, speed);
	analogWrite(enB, speed);
    
    // Вращать левый мотор вперед
	digitalWrite(in1, LOW);
	digitalWrite(in2, HIGH);

	// Вращать правый мотор назад
	digitalWrite(in3, LOW);
	digitalWrite(in4, HIGH);
}

void stopMove() {
	// Остановка моторв
	digitalWrite(in1, LOW);
	digitalWrite(in2, LOW);
	digitalWrite(in3, LOW);
	digitalWrite(in4, LOW);
}


// Эта функция позволяет проверить работу моторов
void motorsTest() {
	// Повернуь на лево со скоростью от 0 до 255 с задержкой в 20мс
	for (int i = 0; i < 256; i++) {
		moveLeft(i);
		delay(20);
	}
	
	// Повернуь на направо со скоростью от 0 до 255 с задержкой в 20мс
	for (int i = 255; i >= 0; --i) {
		moveRight(i);
		delay(20);
	}
	
	// Остановится
    stopMove();
}
```

##### Объяснение кода 

Код  довольно простой и требует подключения каких либо библиотек для работы с моторами. Программа начинается с объявления контактов на плате Arduino к которым подключен наш драйвер L293D.

```c++
// Подключение мотора A
int enA = 9;
int in1 = 8;
int in2 = 7;
// Подключение мотора B
int enB = 3;
int in3 = 5;
int in4 = 4;
```

Далее происходит объявление функций управления направлением и скоростью наших моторов.

`moveForward` - эта функция заставляет вращать оба мотора вперёд на скорости передаваемой параметром `speed` подавая сигнал на ШИМ с помощью функции `AnalogWrite()`. Аналогичным образом реализованы функции `moveReverse`, `moveRight`, `moveLeft`.

```c++
void moveForward(int speed) {
    // Установить параметр скорости для моторов
	analogWrite(enA, speed);
	analogWrite(enB, speed);
    
	// Вращать левый мотор вперед
	digitalWrite(in1, LOW);
	digitalWrite(in2, HIGH);

	// Вращать правый мотор вперед
	digitalWrite(in3, HIGH);
	digitalWrite(in4, LOW);
}
```

В функции `stopMove` происходит остановка моторов. 

```c++
void stopMove() {
	// Остановка моторв
	digitalWrite(in1, LOW);
	digitalWrite(in2, LOW);
	digitalWrite(in3, LOW);
	digitalWrite(in4, LOW);
}
```

`motorsTest()` Эта функция поворачивает машинку на лево с возрастающей скоростью (от 0 до 255), с задержкой в 20 миллисекунд, затем аналогично в противоположную сторону, после чего останавливает моторы.

```c++
// Эта функция позволяет проверить работу моторов
void motorsTest() {
	// Повернуь на лево со скоростью от 0 до 255 с задержкой в 20мс
	for (int i = 0; i < 256; i++) {
		moveLeft(i);
		delay(20);
	}
	
	// Повернуь на право со скоростью от 0 до 255 с задержкой в 20мс
	for (int i = 255; i >= 0; --i) {
		moveRight(i);
		delay(20);
	}
	
	// Остановится
    stopMove();
}
```

#### Измерение и регулировка скорости DC мотров через ИК-модуль

